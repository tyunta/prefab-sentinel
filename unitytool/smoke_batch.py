from __future__ import annotations

import argparse
import json
import subprocess
import sys
import time
from dataclasses import dataclass
from pathlib import Path
from typing import Any

from unitytool.bridge_smoke import load_patch_plan

_PROJECT_ROOT = Path(__file__).resolve().parent.parent
_PROJECT_SMOKE_SCRIPT = _PROJECT_ROOT / "scripts" / "unity_bridge_smoke.py"
UNITY_BRIDGE_SMOKE_SCRIPT = (
    _PROJECT_SMOKE_SCRIPT
    if _PROJECT_SMOKE_SCRIPT.exists()
    else Path("scripts") / "unity_bridge_smoke.py"
)
DEFAULT_EXECUTE_METHOD = "PrefabSentinel.UnityPatchBridge.ApplyFromJson"
DEFAULT_OUT_DIR = Path("reports") / "bridge_smoke"


@dataclass(frozen=True)
class SmokeCase:
    name: str
    plan: Path
    project_path: Path
    expect_failure: bool = False
    expected_applied: int | None = None


def add_arguments(parser: argparse.ArgumentParser) -> None:
    parser.add_argument(
        "--targets",
        nargs="+",
        choices=("avatar", "world", "all"),
        default=["all"],
        help="Smoke targets. 'all' expands to avatar + world.",
    )
    parser.add_argument(
        "--avatar-plan",
        default=str(Path("sample") / "avatar" / "config" / "prefab_patch_plan.json"),
        help="Patch plan for avatar target.",
    )
    parser.add_argument(
        "--world-plan",
        default=str(Path("sample") / "world" / "config" / "prefab_patch_plan.json"),
        help="Patch plan for world target.",
    )
    parser.add_argument(
        "--avatar-project-path",
        default=str(Path("sample") / "avatar"),
        help="Unity project path for avatar target.",
    )
    parser.add_argument(
        "--world-project-path",
        default=str(Path("sample") / "world"),
        help="Unity project path for world target.",
    )
    parser.add_argument(
        "--avatar-expect-failure",
        action="store_true",
        help="Pass --expect-failure for avatar target.",
    )
    parser.add_argument(
        "--world-expect-failure",
        action="store_true",
        help="Pass --expect-failure for world target.",
    )
    parser.add_argument(
        "--avatar-expected-applied",
        type=int,
        default=None,
        help="Optional expected data.applied value for avatar target.",
    )
    parser.add_argument(
        "--world-expected-applied",
        type=int,
        default=None,
        help="Optional expected data.applied value for world target.",
    )
    parser.add_argument(
        "--expect-applied-from-plan",
        action="store_true",
        help=(
            "Infer expected applied count from patch plan ops length for non-failure targets "
            "when target-specific expected-applied is not provided."
        ),
    )
    parser.add_argument(
        "--python",
        default=sys.executable,
        help="Python executable used for child scripts.",
    )
    parser.add_argument(
        "--smoke-script",
        default=str(UNITY_BRIDGE_SMOKE_SCRIPT),
        help="Path to scripts/unity_bridge_smoke.py.",
    )
    parser.add_argument(
        "--bridge-script",
        default=str(Path("tools") / "unity_patch_bridge.py"),
        help="Path to tools/unity_patch_bridge.py.",
    )
    parser.add_argument(
        "--unity-command",
        default=None,
        help="Optional UNITYTOOL_UNITY_COMMAND override.",
    )
    parser.add_argument(
        "--unity-execute-method",
        default=DEFAULT_EXECUTE_METHOD,
        help="UNITYTOOL_UNITY_EXECUTE_METHOD value for all targets.",
    )
    parser.add_argument(
        "--unity-timeout-sec",
        type=int,
        default=None,
        help="Optional fallback UNITYTOOL_UNITY_TIMEOUT_SEC override for all targets.",
    )
    parser.add_argument(
        "--avatar-unity-timeout-sec",
        type=int,
        default=None,
        help="Optional UNITYTOOL_UNITY_TIMEOUT_SEC override for avatar target.",
    )
    parser.add_argument(
        "--world-unity-timeout-sec",
        type=int,
        default=None,
        help="Optional UNITYTOOL_UNITY_TIMEOUT_SEC override for world target.",
    )
    parser.add_argument(
        "--timeout-profile",
        default=None,
        help="Optional timeout profile JSON generated by smoke-history.",
    )
    parser.add_argument(
        "--max-retries",
        type=int,
        default=0,
        help="Retry count for transient smoke failures per target (default: 0).",
    )
    parser.add_argument(
        "--retry-delay-sec",
        type=float,
        default=0.0,
        help="Delay seconds between retries (default: 0.0).",
    )
    parser.add_argument(
        "--out-dir",
        default=str(DEFAULT_OUT_DIR),
        help="Output root directory for per-target artifacts and summary.",
    )
    parser.add_argument(
        "--summary-json",
        default=None,
        help="Optional summary JSON output path (default: <out-dir>/summary.json).",
    )
    parser.add_argument(
        "--summary-md",
        default=None,
        help="Optional summary Markdown output path.",
    )


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        prog="bridge_smoke_samples",
        description="Run unity_bridge_smoke.py for sample avatar/world cases.",
    )
    add_arguments(parser)
    return parser


def _resolve_targets(raw_targets: list[str]) -> list[str]:
    expanded: list[str] = []
    for item in raw_targets:
        if item == "all":
            expanded.extend(["avatar", "world"])
        else:
            expanded.append(item)
    unique: list[str] = []
    seen: set[str] = set()
    for target in expanded:
        if target not in seen:
            seen.add(target)
            unique.append(target)
    return unique


def _build_cases(args: argparse.Namespace) -> list[SmokeCase]:
    targets = _resolve_targets(args.targets)
    cases_map: dict[str, SmokeCase] = {
        "avatar": SmokeCase(
            name="avatar",
            plan=Path(args.avatar_plan),
            project_path=Path(args.avatar_project_path),
            expect_failure=bool(args.avatar_expect_failure),
            expected_applied=args.avatar_expected_applied,
        ),
        "world": SmokeCase(
            name="world",
            plan=Path(args.world_plan),
            project_path=Path(args.world_project_path),
            expect_failure=bool(args.world_expect_failure),
            expected_applied=args.world_expected_applied,
        ),
    }
    return [cases_map[target] for target in targets]


def _load_timeout_profile_map(timeout_profile_path: Path) -> dict[str, int]:
    payload = json.loads(timeout_profile_path.read_text(encoding="utf-8"))
    if not isinstance(payload, dict):
        raise ValueError("timeout profile root must be an object.")

    profiles = payload.get("profiles")
    if not isinstance(profiles, list):
        raise ValueError("timeout profile must include profiles list.")

    mapping: dict[str, int] = {}
    for item in profiles:
        if not isinstance(item, dict):
            raise ValueError("timeout profile entry must be an object.")
        target = item.get("target")
        if not isinstance(target, str) or target not in {"avatar", "world"}:
            raise ValueError("timeout profile target must be avatar/world.")
        recommended_raw = item.get("recommended_timeout_sec")
        try:
            recommended = int(recommended_raw)
        except (TypeError, ValueError):
            raise ValueError("recommended_timeout_sec must be an integer.") from None
        if recommended <= 0:
            raise ValueError("recommended_timeout_sec must be greater than 0.")
        mapping[target] = recommended
    return mapping


def _resolve_case_unity_timeout_sec(
    *,
    case: SmokeCase,
    default_timeout_sec: int | None,
    avatar_timeout_sec: int | None,
    world_timeout_sec: int | None,
    timeout_profile_overrides: dict[str, int],
) -> tuple[int | None, str]:
    per_target_overrides = {
        "avatar": avatar_timeout_sec,
        "world": world_timeout_sec,
    }
    case_override = per_target_overrides.get(case.name)
    if case_override is not None:
        return case_override, "target_override"
    if default_timeout_sec is not None:
        return default_timeout_sec, "default_override"
    profile_timeout = timeout_profile_overrides.get(case.name)
    if profile_timeout is not None:
        return profile_timeout, "profile"
    return None, "none"


def _build_smoke_command(
    *,
    smoke_script: Path,
    python_executable: str,
    bridge_script: Path,
    unity_command: str | None,
    unity_execute_method: str,
    unity_timeout_sec: int | None,
    case: SmokeCase,
    response_out: Path,
    unity_log_file: Path,
) -> list[str]:
    command = [
        python_executable,
        str(smoke_script),
        "--plan",
        str(case.plan),
        "--bridge-script",
        str(bridge_script),
        "--python",
        python_executable,
        "--unity-project-path",
        str(case.project_path),
        "--unity-execute-method",
        unity_execute_method,
        "--unity-log-file",
        str(unity_log_file),
        "--out",
        str(response_out),
    ]
    if unity_command is not None:
        command.extend(["--unity-command", unity_command])
    if unity_timeout_sec is not None:
        command.extend(["--unity-timeout-sec", str(unity_timeout_sec)])
    if case.expect_failure:
        command.append("--expect-failure")
    return command


def _parse_case_payload(
    *,
    case: SmokeCase,
    exit_code: int,
    stdout_text: str,
    stderr_text: str,
) -> dict[str, Any]:
    try:
        payload = json.loads(stdout_text)
    except json.JSONDecodeError:
        payload = {
            "success": False,
            "severity": "error",
            "code": "SMOKE_BATCH_STDOUT_JSON",
            "message": "Child smoke stdout is not valid JSON.",
            "data": {
                "target": case.name,
                "exit_code": exit_code,
                "stdout": stdout_text,
                "stderr": stderr_text,
            },
            "diagnostics": [],
        }
    if not isinstance(payload, dict):
        return {
            "success": False,
            "severity": "error",
            "code": "SMOKE_BATCH_STDOUT_SCHEMA",
            "message": "Child smoke stdout root must be an object.",
            "data": {
                "target": case.name,
                "exit_code": exit_code,
                "stdout": stdout_text,
                "stderr": stderr_text,
            },
            "diagnostics": [],
        }
    return payload


def _extract_applied_count(payload: dict[str, Any]) -> int | None:
    data = payload.get("data")
    if not isinstance(data, dict):
        return None
    applied = data.get("applied")
    return applied if isinstance(applied, int) else None


def _resolve_expected_applied(
    *,
    case: SmokeCase,
    expect_applied_from_plan: bool,
) -> tuple[int | None, str]:
    if case.expected_applied is not None:
        return case.expected_applied, "cli"
    if not expect_applied_from_plan:
        return None, "none"
    if case.expect_failure:
        return None, "skipped_expect_failure"
    plan = load_patch_plan(case.plan)
    ops = plan.get("ops", [])
    return len(ops), "plan_ops"


def _render_markdown_summary(payload: dict[str, Any]) -> str:
    data = payload.get("data", {})
    cases = data.get("cases", [])
    timeout_profile_path = data.get("timeout_profile_path")
    lines = [
        "# Unity Bridge Smoke Batch",
        "",
        f"- Success: {payload.get('success')}",
        f"- Severity: {payload.get('severity')}",
        f"- Code: {payload.get('code')}",
        f"- Message: {payload.get('message')}",
        f"- Total: {data.get('total_cases', 0)}",
        f"- Passed: {data.get('passed_cases', 0)}",
        f"- Failed: {data.get('failed_cases', 0)}",
        (
            f"- Timeout Profile: {timeout_profile_path}"
            if timeout_profile_path
            else "- Timeout Profile: n/a"
        ),
        "",
        "| case | matched | expected_applied | expected_source | actual_applied | applied_matches | attempts | duration_sec | timeout_sec | timeout_source | exit_code | response_code | response_path | unity_log_file |",
        "| --- | --- | ---: | --- | ---: | --- | ---: | ---: | ---: | --- | ---: | --- | --- | --- |",
    ]
    for case in cases:
        timeout_sec = case.get("unity_timeout_sec")
        if timeout_sec is None:
            timeout_sec = ""
        duration_sec = case.get("duration_sec")
        if duration_sec is None:
            duration_sec = ""
        expected_applied = case.get("expected_applied")
        if expected_applied is None:
            expected_applied = ""
        expected_applied_source = case.get("expected_applied_source")
        if expected_applied_source is None:
            expected_applied_source = ""
        actual_applied = case.get("actual_applied")
        if actual_applied is None:
            actual_applied = ""
        applied_matches = case.get("applied_matches")
        if applied_matches is None:
            applied_matches = ""
        lines.append(
            "| {name} | {matched} | {expected_applied} | {expected_applied_source} | {actual_applied} | {applied_matches} | {attempts} | {duration_sec} | {timeout_sec} | {timeout_source} | {exit_code} | {response_code} | {response_path} | {unity_log_file} |".format(
                name=case.get("name", ""),
                matched=case.get("matched_expectation", False),
                expected_applied=expected_applied,
                expected_applied_source=expected_applied_source,
                actual_applied=actual_applied,
                applied_matches=applied_matches,
                attempts=case.get("attempts", 1),
                duration_sec=duration_sec,
                timeout_sec=timeout_sec,
                timeout_source=case.get("timeout_source", ""),
                exit_code=case.get("exit_code", ""),
                response_code=case.get("response_code", ""),
                response_path=case.get("response_path", ""),
                unity_log_file=case.get("unity_log_file", ""),
            )
        )
    return "\n".join(lines) + "\n"


def _run_smoke_with_retries(
    *,
    command: list[str],
    max_retries: int,
    retry_delay_sec: float,
) -> tuple[subprocess.CompletedProcess[str], int, float]:
    attempts = 0
    started_at = time.perf_counter()
    while True:
        attempts += 1
        completed = subprocess.run(
            command,
            capture_output=True,
            text=True,
            encoding="utf-8",
            errors="replace",
            check=False,
        )
        if completed.returncode == 0:
            elapsed_sec = time.perf_counter() - started_at
            return completed, attempts, elapsed_sec
        if attempts > max_retries:
            elapsed_sec = time.perf_counter() - started_at
            return completed, attempts, elapsed_sec
        if retry_delay_sec > 0.0:
            time.sleep(retry_delay_sec)


def run_from_args(args: argparse.Namespace, parser: argparse.ArgumentParser) -> int:
    if args.max_retries < 0:
        parser.error("--max-retries must be greater than or equal to 0.")
    if args.retry_delay_sec < 0.0:
        parser.error("--retry-delay-sec must be greater than or equal to 0.")

    timeout_args = {
        "--unity-timeout-sec": args.unity_timeout_sec,
        "--avatar-unity-timeout-sec": args.avatar_unity_timeout_sec,
        "--world-unity-timeout-sec": args.world_unity_timeout_sec,
    }
    for arg_name, arg_value in timeout_args.items():
        if arg_value is not None and arg_value <= 0:
            parser.error(f"{arg_name} must be greater than 0.")
    expected_applied_args = {
        "--avatar-expected-applied": args.avatar_expected_applied,
        "--world-expected-applied": args.world_expected_applied,
    }
    for arg_name, arg_value in expected_applied_args.items():
        if arg_value is not None and arg_value < 0:
            parser.error(f"{arg_name} must be greater than or equal to 0.")

    timeout_profile_path: Path | None = None
    timeout_profile_overrides: dict[str, int] = {}
    if args.timeout_profile:
        timeout_profile_path = Path(args.timeout_profile)
        if not timeout_profile_path.exists():
            parser.error(f"--timeout-profile not found: {timeout_profile_path}")
        try:
            timeout_profile_overrides = _load_timeout_profile_map(timeout_profile_path)
        except (OSError, json.JSONDecodeError, ValueError) as exc:
            parser.error(f"Failed to parse --timeout-profile: {exc}")

    smoke_script = Path(args.smoke_script)
    bridge_script = Path(args.bridge_script)
    out_dir = Path(args.out_dir)
    out_dir.mkdir(parents=True, exist_ok=True)

    cases = _build_cases(args)
    results: list[dict[str, Any]] = []
    for case in cases:
        if not case.plan.exists():
            raise FileNotFoundError(f"Plan not found for {case.name}: {case.plan}")
        if not case.project_path.exists():
            raise FileNotFoundError(
                f"Project path not found for {case.name}: {case.project_path}"
            )

        case_timeout_sec, timeout_source = _resolve_case_unity_timeout_sec(
            case=case,
            default_timeout_sec=args.unity_timeout_sec,
            avatar_timeout_sec=args.avatar_unity_timeout_sec,
            world_timeout_sec=args.world_unity_timeout_sec,
            timeout_profile_overrides=timeout_profile_overrides,
        )

        case_dir = out_dir / case.name
        case_dir.mkdir(parents=True, exist_ok=True)
        response_path = case_dir / "response.json"
        unity_log_file = case_dir / "unity.log"
        command = _build_smoke_command(
            smoke_script=smoke_script,
            python_executable=args.python,
            bridge_script=bridge_script,
            unity_command=args.unity_command,
            unity_execute_method=args.unity_execute_method,
            unity_timeout_sec=case_timeout_sec,
            case=case,
            response_out=response_path,
            unity_log_file=unity_log_file,
        )
        completed, attempts, duration_sec = _run_smoke_with_retries(
            command=command,
            max_retries=args.max_retries,
            retry_delay_sec=args.retry_delay_sec,
        )
        case_payload = _parse_case_payload(
            case=case,
            exit_code=completed.returncode,
            stdout_text=completed.stdout,
            stderr_text=completed.stderr,
        )
        try:
            expected_applied, expected_applied_source = _resolve_expected_applied(
                case=case,
                expect_applied_from_plan=args.expect_applied_from_plan,
            )
        except (OSError, json.JSONDecodeError, ValueError) as exc:
            raise ValueError(
                f"Failed to resolve expected applied count for {case.name}: {exc}"
            ) from exc
        actual_applied = _extract_applied_count(case_payload)
        applied_matches: bool | None = None
        if expected_applied is not None:
            applied_matches = actual_applied == expected_applied
        matched_expectation = completed.returncode == 0
        if applied_matches is False:
            matched_expectation = False
        if not response_path.exists():
            response_path.write_text(
                json.dumps(case_payload, ensure_ascii=False, indent=2),
                encoding="utf-8",
            )
        results.append(
            {
                "name": case.name,
                "plan": str(case.plan),
                "project_path": str(case.project_path),
                "expect_failure": case.expect_failure,
                "expected_applied": expected_applied,
                "expected_applied_source": expected_applied_source,
                "actual_applied": actual_applied,
                "applied_matches": applied_matches,
                "matched_expectation": matched_expectation,
                "attempts": attempts,
                "duration_sec": round(duration_sec, 6),
                "unity_timeout_sec": case_timeout_sec,
                "timeout_source": timeout_source,
                "exit_code": completed.returncode,
                "response_code": str(case_payload.get("code", "")),
                "response_severity": str(case_payload.get("severity", "")),
                "response_path": str(response_path),
                "unity_log_file": str(unity_log_file),
            }
        )

    failed_cases = [item for item in results if not item["matched_expectation"]]
    summary_payload = {
        "success": len(failed_cases) == 0,
        "severity": "info" if len(failed_cases) == 0 else "error",
        "code": "SMOKE_BATCH_OK" if len(failed_cases) == 0 else "SMOKE_BATCH_FAILED",
        "message": (
            "All bridge smoke cases matched expectations."
            if len(failed_cases) == 0
            else "Some bridge smoke cases failed to match expectations."
        ),
        "data": {
            "total_cases": len(results),
            "passed_cases": len(results) - len(failed_cases),
            "failed_cases": len(failed_cases),
            "timeout_profile_path": (
                str(timeout_profile_path) if timeout_profile_path is not None else None
            ),
            "timeout_profile_targets": sorted(timeout_profile_overrides.keys()),
            "cases": results,
        },
        "diagnostics": [],
    }

    summary_json = Path(args.summary_json) if args.summary_json else out_dir / "summary.json"
    summary_json.parent.mkdir(parents=True, exist_ok=True)
    summary_json.write_text(
        json.dumps(summary_payload, ensure_ascii=False, indent=2),
        encoding="utf-8",
    )

    if args.summary_md:
        summary_md = Path(args.summary_md)
        summary_md.parent.mkdir(parents=True, exist_ok=True)
        summary_md.write_text(
            _render_markdown_summary(summary_payload),
            encoding="utf-8",
        )

    print(summary_json)
    return 0 if summary_payload["success"] else 1


def main(argv: list[str] | None = None) -> int:
    parser = build_parser()
    args = parser.parse_args(argv)
    return run_from_args(args, parser)


if __name__ == "__main__":
    raise SystemExit(main())
